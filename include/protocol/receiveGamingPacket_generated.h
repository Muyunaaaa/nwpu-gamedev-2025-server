// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_RECEIVEGAMINGPACKET_MYU_NET_H_
#define FLATBUFFERS_GENERATED_RECEIVEGAMINGPACKET_MYU_NET_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 9 &&
              FLATBUFFERS_VERSION_REVISION == 23,
             "Non-compatible flatbuffers version included");

namespace myu {
namespace net {

struct PacketHeader;
struct PacketHeaderBuilder;

struct FirePacket;
struct FirePacketBuilder;

struct MovePacket;
struct MovePacketBuilder;

struct PlantBombEvent;
struct PlantBombEventBuilder;

struct DefuseBombEvent;
struct DefuseBombEventBuilder;

struct PurchaseEvent;
struct PurchaseEventBuilder;

struct PlayerInfo;
struct PlayerInfoBuilder;

struct NetMessage;
struct NetMessageBuilder;

enum Weapon : int8_t {
  Weapon_WEAPON_NONE = 0,
  Weapon_GLOCK = 1,
  Weapon_USP = 2,
  Weapon_DEAGLE = 3,
  Weapon_AK47 = 4,
  Weapon_M4A1 = 5,
  Weapon_MIN = Weapon_WEAPON_NONE,
  Weapon_MAX = Weapon_M4A1
};

inline const Weapon (&EnumValuesWeapon())[6] {
  static const Weapon values[] = {
    Weapon_WEAPON_NONE,
    Weapon_GLOCK,
    Weapon_USP,
    Weapon_DEAGLE,
    Weapon_AK47,
    Weapon_M4A1
  };
  return values;
}

inline const char * const *EnumNamesWeapon() {
  static const char * const names[7] = {
    "WEAPON_NONE",
    "GLOCK",
    "USP",
    "DEAGLE",
    "AK47",
    "M4A1",
    nullptr
  };
  return names;
}

inline const char *EnumNameWeapon(Weapon e) {
  if (::flatbuffers::IsOutRange(e, Weapon_WEAPON_NONE, Weapon_M4A1)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesWeapon()[index];
}

enum WeaponSlot : int8_t {
  WeaponSlot_SLOT_PRIMARY = 0,
  WeaponSlot_SLOT_SECONDARY = 1,
  WeaponSlot_MIN = WeaponSlot_SLOT_PRIMARY,
  WeaponSlot_MAX = WeaponSlot_SLOT_SECONDARY
};

inline const WeaponSlot (&EnumValuesWeaponSlot())[2] {
  static const WeaponSlot values[] = {
    WeaponSlot_SLOT_PRIMARY,
    WeaponSlot_SLOT_SECONDARY
  };
  return values;
}

inline const char * const *EnumNamesWeaponSlot() {
  static const char * const names[3] = {
    "SLOT_PRIMARY",
    "SLOT_SECONDARY",
    nullptr
  };
  return names;
}

inline const char *EnumNameWeaponSlot(WeaponSlot e) {
  if (::flatbuffers::IsOutRange(e, WeaponSlot_SLOT_PRIMARY, WeaponSlot_SLOT_SECONDARY)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesWeaponSlot()[index];
}

enum PacketUnion : uint8_t {
  PacketUnion_NONE = 0,
  PacketUnion_FirePacket = 1,
  PacketUnion_MovePacket = 2,
  PacketUnion_PlayerInfo = 3,
  PacketUnion_PlantBombEvent = 4,
  PacketUnion_DefuseBombEvent = 5,
  PacketUnion_PurchaseEvent = 6,
  PacketUnion_MIN = PacketUnion_NONE,
  PacketUnion_MAX = PacketUnion_PurchaseEvent
};

inline const PacketUnion (&EnumValuesPacketUnion())[7] {
  static const PacketUnion values[] = {
    PacketUnion_NONE,
    PacketUnion_FirePacket,
    PacketUnion_MovePacket,
    PacketUnion_PlayerInfo,
    PacketUnion_PlantBombEvent,
    PacketUnion_DefuseBombEvent,
    PacketUnion_PurchaseEvent
  };
  return values;
}

inline const char * const *EnumNamesPacketUnion() {
  static const char * const names[8] = {
    "NONE",
    "FirePacket",
    "MovePacket",
    "PlayerInfo",
    "PlantBombEvent",
    "DefuseBombEvent",
    "PurchaseEvent",
    nullptr
  };
  return names;
}

inline const char *EnumNamePacketUnion(PacketUnion e) {
  if (::flatbuffers::IsOutRange(e, PacketUnion_NONE, PacketUnion_PurchaseEvent)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPacketUnion()[index];
}

template<typename T> struct PacketUnionTraits {
  static const PacketUnion enum_value = PacketUnion_NONE;
};

template<> struct PacketUnionTraits<myu::net::FirePacket> {
  static const PacketUnion enum_value = PacketUnion_FirePacket;
};

template<> struct PacketUnionTraits<myu::net::MovePacket> {
  static const PacketUnion enum_value = PacketUnion_MovePacket;
};

template<> struct PacketUnionTraits<myu::net::PlayerInfo> {
  static const PacketUnion enum_value = PacketUnion_PlayerInfo;
};

template<> struct PacketUnionTraits<myu::net::PlantBombEvent> {
  static const PacketUnion enum_value = PacketUnion_PlantBombEvent;
};

template<> struct PacketUnionTraits<myu::net::DefuseBombEvent> {
  static const PacketUnion enum_value = PacketUnion_DefuseBombEvent;
};

template<> struct PacketUnionTraits<myu::net::PurchaseEvent> {
  static const PacketUnion enum_value = PacketUnion_PurchaseEvent;
};

bool VerifyPacketUnion(::flatbuffers::Verifier &verifier, const void *obj, PacketUnion type);
bool VerifyPacketUnionVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

struct PacketHeader FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PacketHeaderBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CLIENTTICK = 4,
    VT_CLIENTTIME = 6
  };
  uint64_t clientTick() const {
    return GetField<uint64_t>(VT_CLIENTTICK, 0);
  }
  uint64_t clientTime() const {
    return GetField<uint64_t>(VT_CLIENTTIME, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_CLIENTTICK, 8) &&
           VerifyField<uint64_t>(verifier, VT_CLIENTTIME, 8) &&
           verifier.EndTable();
  }
};

struct PacketHeaderBuilder {
  typedef PacketHeader Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_clientTick(uint64_t clientTick) {
    fbb_.AddElement<uint64_t>(PacketHeader::VT_CLIENTTICK, clientTick, 0);
  }
  void add_clientTime(uint64_t clientTime) {
    fbb_.AddElement<uint64_t>(PacketHeader::VT_CLIENTTIME, clientTime, 0);
  }
  explicit PacketHeaderBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PacketHeader> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PacketHeader>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PacketHeader> CreatePacketHeader(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t clientTick = 0,
    uint64_t clientTime = 0) {
  PacketHeaderBuilder builder_(_fbb);
  builder_.add_clientTime(clientTime);
  builder_.add_clientTick(clientTick);
  return builder_.Finish();
}

struct FirePacket FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FirePacketBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TEMPID = 4,
    VT_ORIGINX = 6,
    VT_ORIGINY = 8,
    VT_ORIGINZ = 10,
    VT_DIRX = 12,
    VT_DIRY = 14,
    VT_DIRZ = 16,
    VT_WEAPONSLOT = 18,
    VT_SEQUENCE = 20
  };
  uint16_t tempId() const {
    return GetField<uint16_t>(VT_TEMPID, 0);
  }
  float originX() const {
    return GetField<float>(VT_ORIGINX, 0.0f);
  }
  float originY() const {
    return GetField<float>(VT_ORIGINY, 0.0f);
  }
  float originZ() const {
    return GetField<float>(VT_ORIGINZ, 0.0f);
  }
  float dirX() const {
    return GetField<float>(VT_DIRX, 0.0f);
  }
  float dirY() const {
    return GetField<float>(VT_DIRY, 0.0f);
  }
  float dirZ() const {
    return GetField<float>(VT_DIRZ, 0.0f);
  }
  myu::net::WeaponSlot weaponSlot() const {
    return static_cast<myu::net::WeaponSlot>(GetField<int8_t>(VT_WEAPONSLOT, 0));
  }
  uint32_t sequence() const {
    return GetField<uint32_t>(VT_SEQUENCE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_TEMPID, 2) &&
           VerifyField<float>(verifier, VT_ORIGINX, 4) &&
           VerifyField<float>(verifier, VT_ORIGINY, 4) &&
           VerifyField<float>(verifier, VT_ORIGINZ, 4) &&
           VerifyField<float>(verifier, VT_DIRX, 4) &&
           VerifyField<float>(verifier, VT_DIRY, 4) &&
           VerifyField<float>(verifier, VT_DIRZ, 4) &&
           VerifyField<int8_t>(verifier, VT_WEAPONSLOT, 1) &&
           VerifyField<uint32_t>(verifier, VT_SEQUENCE, 4) &&
           verifier.EndTable();
  }
};

struct FirePacketBuilder {
  typedef FirePacket Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_tempId(uint16_t tempId) {
    fbb_.AddElement<uint16_t>(FirePacket::VT_TEMPID, tempId, 0);
  }
  void add_originX(float originX) {
    fbb_.AddElement<float>(FirePacket::VT_ORIGINX, originX, 0.0f);
  }
  void add_originY(float originY) {
    fbb_.AddElement<float>(FirePacket::VT_ORIGINY, originY, 0.0f);
  }
  void add_originZ(float originZ) {
    fbb_.AddElement<float>(FirePacket::VT_ORIGINZ, originZ, 0.0f);
  }
  void add_dirX(float dirX) {
    fbb_.AddElement<float>(FirePacket::VT_DIRX, dirX, 0.0f);
  }
  void add_dirY(float dirY) {
    fbb_.AddElement<float>(FirePacket::VT_DIRY, dirY, 0.0f);
  }
  void add_dirZ(float dirZ) {
    fbb_.AddElement<float>(FirePacket::VT_DIRZ, dirZ, 0.0f);
  }
  void add_weaponSlot(myu::net::WeaponSlot weaponSlot) {
    fbb_.AddElement<int8_t>(FirePacket::VT_WEAPONSLOT, static_cast<int8_t>(weaponSlot), 0);
  }
  void add_sequence(uint32_t sequence) {
    fbb_.AddElement<uint32_t>(FirePacket::VT_SEQUENCE, sequence, 0);
  }
  explicit FirePacketBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FirePacket> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FirePacket>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FirePacket> CreateFirePacket(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t tempId = 0,
    float originX = 0.0f,
    float originY = 0.0f,
    float originZ = 0.0f,
    float dirX = 0.0f,
    float dirY = 0.0f,
    float dirZ = 0.0f,
    myu::net::WeaponSlot weaponSlot = myu::net::WeaponSlot_SLOT_PRIMARY,
    uint32_t sequence = 0) {
  FirePacketBuilder builder_(_fbb);
  builder_.add_sequence(sequence);
  builder_.add_dirZ(dirZ);
  builder_.add_dirY(dirY);
  builder_.add_dirX(dirX);
  builder_.add_originZ(originZ);
  builder_.add_originY(originY);
  builder_.add_originX(originX);
  builder_.add_tempId(tempId);
  builder_.add_weaponSlot(weaponSlot);
  return builder_.Finish();
}

struct MovePacket FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MovePacketBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TEMPID = 4,
    VT_MOVEX = 6,
    VT_MOVEY = 8,
    VT_MOVEZ = 10,
    VT_YAWRADIAN = 12,
    VT_PITCHRADIAN = 14,
    VT_JUMP = 16,
    VT_CROUCH = 18,
    VT_SPRINT = 20,
    VT_SEQUENCE = 22
  };
  uint16_t tempId() const {
    return GetField<uint16_t>(VT_TEMPID, 0);
  }
  float moveX() const {
    return GetField<float>(VT_MOVEX, 0.0f);
  }
  float moveY() const {
    return GetField<float>(VT_MOVEY, 0.0f);
  }
  float moveZ() const {
    return GetField<float>(VT_MOVEZ, 0.0f);
  }
  float yawRadian() const {
    return GetField<float>(VT_YAWRADIAN, 0.0f);
  }
  float pitchRadian() const {
    return GetField<float>(VT_PITCHRADIAN, 0.0f);
  }
  bool jump() const {
    return GetField<uint8_t>(VT_JUMP, 0) != 0;
  }
  bool crouch() const {
    return GetField<uint8_t>(VT_CROUCH, 0) != 0;
  }
  bool sprint() const {
    return GetField<uint8_t>(VT_SPRINT, 0) != 0;
  }
  uint32_t sequence() const {
    return GetField<uint32_t>(VT_SEQUENCE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_TEMPID, 2) &&
           VerifyField<float>(verifier, VT_MOVEX, 4) &&
           VerifyField<float>(verifier, VT_MOVEY, 4) &&
           VerifyField<float>(verifier, VT_MOVEZ, 4) &&
           VerifyField<float>(verifier, VT_YAWRADIAN, 4) &&
           VerifyField<float>(verifier, VT_PITCHRADIAN, 4) &&
           VerifyField<uint8_t>(verifier, VT_JUMP, 1) &&
           VerifyField<uint8_t>(verifier, VT_CROUCH, 1) &&
           VerifyField<uint8_t>(verifier, VT_SPRINT, 1) &&
           VerifyField<uint32_t>(verifier, VT_SEQUENCE, 4) &&
           verifier.EndTable();
  }
};

struct MovePacketBuilder {
  typedef MovePacket Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_tempId(uint16_t tempId) {
    fbb_.AddElement<uint16_t>(MovePacket::VT_TEMPID, tempId, 0);
  }
  void add_moveX(float moveX) {
    fbb_.AddElement<float>(MovePacket::VT_MOVEX, moveX, 0.0f);
  }
  void add_moveY(float moveY) {
    fbb_.AddElement<float>(MovePacket::VT_MOVEY, moveY, 0.0f);
  }
  void add_moveZ(float moveZ) {
    fbb_.AddElement<float>(MovePacket::VT_MOVEZ, moveZ, 0.0f);
  }
  void add_yawRadian(float yawRadian) {
    fbb_.AddElement<float>(MovePacket::VT_YAWRADIAN, yawRadian, 0.0f);
  }
  void add_pitchRadian(float pitchRadian) {
    fbb_.AddElement<float>(MovePacket::VT_PITCHRADIAN, pitchRadian, 0.0f);
  }
  void add_jump(bool jump) {
    fbb_.AddElement<uint8_t>(MovePacket::VT_JUMP, static_cast<uint8_t>(jump), 0);
  }
  void add_crouch(bool crouch) {
    fbb_.AddElement<uint8_t>(MovePacket::VT_CROUCH, static_cast<uint8_t>(crouch), 0);
  }
  void add_sprint(bool sprint) {
    fbb_.AddElement<uint8_t>(MovePacket::VT_SPRINT, static_cast<uint8_t>(sprint), 0);
  }
  void add_sequence(uint32_t sequence) {
    fbb_.AddElement<uint32_t>(MovePacket::VT_SEQUENCE, sequence, 0);
  }
  explicit MovePacketBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MovePacket> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MovePacket>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MovePacket> CreateMovePacket(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t tempId = 0,
    float moveX = 0.0f,
    float moveY = 0.0f,
    float moveZ = 0.0f,
    float yawRadian = 0.0f,
    float pitchRadian = 0.0f,
    bool jump = false,
    bool crouch = false,
    bool sprint = false,
    uint32_t sequence = 0) {
  MovePacketBuilder builder_(_fbb);
  builder_.add_sequence(sequence);
  builder_.add_pitchRadian(pitchRadian);
  builder_.add_yawRadian(yawRadian);
  builder_.add_moveZ(moveZ);
  builder_.add_moveY(moveY);
  builder_.add_moveX(moveX);
  builder_.add_tempId(tempId);
  builder_.add_sprint(sprint);
  builder_.add_crouch(crouch);
  builder_.add_jump(jump);
  return builder_.Finish();
}

struct PlantBombEvent FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PlantBombEventBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TEMPID = 4,
    VT_BOMBSITE = 6
  };
  uint16_t tempId() const {
    return GetField<uint16_t>(VT_TEMPID, 0);
  }
  uint16_t bombSite() const {
    return GetField<uint16_t>(VT_BOMBSITE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_TEMPID, 2) &&
           VerifyField<uint16_t>(verifier, VT_BOMBSITE, 2) &&
           verifier.EndTable();
  }
};

struct PlantBombEventBuilder {
  typedef PlantBombEvent Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_tempId(uint16_t tempId) {
    fbb_.AddElement<uint16_t>(PlantBombEvent::VT_TEMPID, tempId, 0);
  }
  void add_bombSite(uint16_t bombSite) {
    fbb_.AddElement<uint16_t>(PlantBombEvent::VT_BOMBSITE, bombSite, 0);
  }
  explicit PlantBombEventBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PlantBombEvent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PlantBombEvent>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PlantBombEvent> CreatePlantBombEvent(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t tempId = 0,
    uint16_t bombSite = 0) {
  PlantBombEventBuilder builder_(_fbb);
  builder_.add_bombSite(bombSite);
  builder_.add_tempId(tempId);
  return builder_.Finish();
}

struct DefuseBombEvent FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DefuseBombEventBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TEMPID = 4
  };
  uint16_t tempId() const {
    return GetField<uint16_t>(VT_TEMPID, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_TEMPID, 2) &&
           verifier.EndTable();
  }
};

struct DefuseBombEventBuilder {
  typedef DefuseBombEvent Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_tempId(uint16_t tempId) {
    fbb_.AddElement<uint16_t>(DefuseBombEvent::VT_TEMPID, tempId, 0);
  }
  explicit DefuseBombEventBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DefuseBombEvent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DefuseBombEvent>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DefuseBombEvent> CreateDefuseBombEvent(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t tempId = 0) {
  DefuseBombEventBuilder builder_(_fbb);
  builder_.add_tempId(tempId);
  return builder_.Finish();
}

struct PurchaseEvent FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PurchaseEventBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TEMPID = 4,
    VT_WEAPON = 6
  };
  uint16_t tempId() const {
    return GetField<uint16_t>(VT_TEMPID, 0);
  }
  myu::net::Weapon weapon() const {
    return static_cast<myu::net::Weapon>(GetField<int8_t>(VT_WEAPON, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_TEMPID, 2) &&
           VerifyField<int8_t>(verifier, VT_WEAPON, 1) &&
           verifier.EndTable();
  }
};

struct PurchaseEventBuilder {
  typedef PurchaseEvent Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_tempId(uint16_t tempId) {
    fbb_.AddElement<uint16_t>(PurchaseEvent::VT_TEMPID, tempId, 0);
  }
  void add_weapon(myu::net::Weapon weapon) {
    fbb_.AddElement<int8_t>(PurchaseEvent::VT_WEAPON, static_cast<int8_t>(weapon), 0);
  }
  explicit PurchaseEventBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PurchaseEvent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PurchaseEvent>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PurchaseEvent> CreatePurchaseEvent(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t tempId = 0,
    myu::net::Weapon weapon = myu::net::Weapon_WEAPON_NONE) {
  PurchaseEventBuilder builder_(_fbb);
  builder_.add_tempId(tempId);
  builder_.add_weapon(weapon);
  return builder_.Finish();
}

struct PlayerInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PlayerInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_READY = 6
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  bool ready() const {
    return GetField<uint8_t>(VT_READY, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint8_t>(verifier, VT_READY, 1) &&
           verifier.EndTable();
  }
};

struct PlayerInfoBuilder {
  typedef PlayerInfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(PlayerInfo::VT_NAME, name);
  }
  void add_ready(bool ready) {
    fbb_.AddElement<uint8_t>(PlayerInfo::VT_READY, static_cast<uint8_t>(ready), 0);
  }
  explicit PlayerInfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PlayerInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PlayerInfo>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PlayerInfo> CreatePlayerInfo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    bool ready = false) {
  PlayerInfoBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_ready(ready);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PlayerInfo> CreatePlayerInfoDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    bool ready = false) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return myu::net::CreatePlayerInfo(
      _fbb,
      name__,
      ready);
}

struct NetMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NetMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HEADER = 4,
    VT_PACKET_TYPE = 6,
    VT_PACKET = 8
  };
  const myu::net::PacketHeader *header() const {
    return GetPointer<const myu::net::PacketHeader *>(VT_HEADER);
  }
  myu::net::PacketUnion packet_type() const {
    return static_cast<myu::net::PacketUnion>(GetField<uint8_t>(VT_PACKET_TYPE, 0));
  }
  const void *packet() const {
    return GetPointer<const void *>(VT_PACKET);
  }
  template<typename T> const T *packet_as() const;
  const myu::net::FirePacket *packet_as_FirePacket() const {
    return packet_type() == myu::net::PacketUnion_FirePacket ? static_cast<const myu::net::FirePacket *>(packet()) : nullptr;
  }
  const myu::net::MovePacket *packet_as_MovePacket() const {
    return packet_type() == myu::net::PacketUnion_MovePacket ? static_cast<const myu::net::MovePacket *>(packet()) : nullptr;
  }
  const myu::net::PlayerInfo *packet_as_PlayerInfo() const {
    return packet_type() == myu::net::PacketUnion_PlayerInfo ? static_cast<const myu::net::PlayerInfo *>(packet()) : nullptr;
  }
  const myu::net::PlantBombEvent *packet_as_PlantBombEvent() const {
    return packet_type() == myu::net::PacketUnion_PlantBombEvent ? static_cast<const myu::net::PlantBombEvent *>(packet()) : nullptr;
  }
  const myu::net::DefuseBombEvent *packet_as_DefuseBombEvent() const {
    return packet_type() == myu::net::PacketUnion_DefuseBombEvent ? static_cast<const myu::net::DefuseBombEvent *>(packet()) : nullptr;
  }
  const myu::net::PurchaseEvent *packet_as_PurchaseEvent() const {
    return packet_type() == myu::net::PacketUnion_PurchaseEvent ? static_cast<const myu::net::PurchaseEvent *>(packet()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyField<uint8_t>(verifier, VT_PACKET_TYPE, 1) &&
           VerifyOffset(verifier, VT_PACKET) &&
           VerifyPacketUnion(verifier, packet(), packet_type()) &&
           verifier.EndTable();
  }
};

template<> inline const myu::net::FirePacket *NetMessage::packet_as<myu::net::FirePacket>() const {
  return packet_as_FirePacket();
}

template<> inline const myu::net::MovePacket *NetMessage::packet_as<myu::net::MovePacket>() const {
  return packet_as_MovePacket();
}

template<> inline const myu::net::PlayerInfo *NetMessage::packet_as<myu::net::PlayerInfo>() const {
  return packet_as_PlayerInfo();
}

template<> inline const myu::net::PlantBombEvent *NetMessage::packet_as<myu::net::PlantBombEvent>() const {
  return packet_as_PlantBombEvent();
}

template<> inline const myu::net::DefuseBombEvent *NetMessage::packet_as<myu::net::DefuseBombEvent>() const {
  return packet_as_DefuseBombEvent();
}

template<> inline const myu::net::PurchaseEvent *NetMessage::packet_as<myu::net::PurchaseEvent>() const {
  return packet_as_PurchaseEvent();
}

struct NetMessageBuilder {
  typedef NetMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_header(::flatbuffers::Offset<myu::net::PacketHeader> header) {
    fbb_.AddOffset(NetMessage::VT_HEADER, header);
  }
  void add_packet_type(myu::net::PacketUnion packet_type) {
    fbb_.AddElement<uint8_t>(NetMessage::VT_PACKET_TYPE, static_cast<uint8_t>(packet_type), 0);
  }
  void add_packet(::flatbuffers::Offset<void> packet) {
    fbb_.AddOffset(NetMessage::VT_PACKET, packet);
  }
  explicit NetMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NetMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NetMessage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NetMessage> CreateNetMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<myu::net::PacketHeader> header = 0,
    myu::net::PacketUnion packet_type = myu::net::PacketUnion_NONE,
    ::flatbuffers::Offset<void> packet = 0) {
  NetMessageBuilder builder_(_fbb);
  builder_.add_packet(packet);
  builder_.add_header(header);
  builder_.add_packet_type(packet_type);
  return builder_.Finish();
}

inline bool VerifyPacketUnion(::flatbuffers::Verifier &verifier, const void *obj, PacketUnion type) {
  switch (type) {
    case PacketUnion_NONE: {
      return true;
    }
    case PacketUnion_FirePacket: {
      auto ptr = reinterpret_cast<const myu::net::FirePacket *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PacketUnion_MovePacket: {
      auto ptr = reinterpret_cast<const myu::net::MovePacket *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PacketUnion_PlayerInfo: {
      auto ptr = reinterpret_cast<const myu::net::PlayerInfo *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PacketUnion_PlantBombEvent: {
      auto ptr = reinterpret_cast<const myu::net::PlantBombEvent *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PacketUnion_DefuseBombEvent: {
      auto ptr = reinterpret_cast<const myu::net::DefuseBombEvent *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PacketUnion_PurchaseEvent: {
      auto ptr = reinterpret_cast<const myu::net::PurchaseEvent *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyPacketUnionVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyPacketUnion(
        verifier,  values->Get(i), types->GetEnum<PacketUnion>(i))) {
      return false;
    }
  }
  return true;
}

inline const myu::net::NetMessage *GetNetMessage(const void *buf) {
  return ::flatbuffers::GetRoot<myu::net::NetMessage>(buf);
}

inline const myu::net::NetMessage *GetSizePrefixedNetMessage(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<myu::net::NetMessage>(buf);
}

inline bool VerifyNetMessageBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<myu::net::NetMessage>(nullptr);
}

inline bool VerifySizePrefixedNetMessageBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<myu::net::NetMessage>(nullptr);
}

inline void FinishNetMessageBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<myu::net::NetMessage> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedNetMessageBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<myu::net::NetMessage> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace net
}  // namespace myu

#endif  // FLATBUFFERS_GENERATED_RECEIVEGAMINGPACKET_MYU_NET_H_
