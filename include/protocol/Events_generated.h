// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_EVENTS_MOE_NET_H_
#define FLATBUFFERS_GENERATED_EVENTS_MOE_NET_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 9 &&
              FLATBUFFERS_VERSION_REVISION == 23,
             "Non-compatible flatbuffers version included");

#include "PlayerInfo_generated.h"
#include "PlayerTeam_generated.h"
#include "Weapon_generated.h"

namespace moe {
namespace net {

struct PlayerJoinedEvent;
struct PlayerJoinedEventBuilder;

struct PlayerLeftEvent;
struct PlayerLeftEventBuilder;

struct GameStartedEvent;
struct GameStartedEventBuilder;

struct RoundPurchaseStartedEvent;
struct RoundPurchaseStartedEventBuilder;

struct RoundStartedEvent;
struct RoundStartedEventBuilder;

struct RoundEndedEvent;
struct RoundEndedEventBuilder;

struct PlayerKilledEvent;
struct PlayerKilledEventBuilder;

struct PlayerOpenFireEvent;
struct PlayerOpenFireEventBuilder;

struct BombPlantedEvent;
struct BombPlantedEventBuilder;

struct BombDefusedEvent;
struct BombDefusedEventBuilder;

struct ChatMessageEvent;
struct ChatMessageEventBuilder;

struct GameEndedEvent;
struct GameEndedEventBuilder;

struct PurchaseEvent;
struct PurchaseEventBuilder;

struct GameEvent;
struct GameEventBuilder;

enum EventData : uint8_t {
  EventData_NONE = 0,
  EventData_PlayerJoinedEvent = 1,
  EventData_PlayerLeftEvent = 2,
  EventData_GameStartedEvent = 3,
  EventData_RoundPurchaseStartedEvent = 4,
  EventData_RoundStartedEvent = 5,
  EventData_RoundEndedEvent = 6,
  EventData_PlayerKilledEvent = 7,
  EventData_PlayerOpenFireEvent = 8,
  EventData_BombPlantedEvent = 9,
  EventData_BombDefusedEvent = 10,
  EventData_ChatMessageEvent = 11,
  EventData_GameEndedEvent = 12,
  EventData_PurchaseEvent = 13,
  EventData_MIN = EventData_NONE,
  EventData_MAX = EventData_PurchaseEvent
};

inline const EventData (&EnumValuesEventData())[14] {
  static const EventData values[] = {
    EventData_NONE,
    EventData_PlayerJoinedEvent,
    EventData_PlayerLeftEvent,
    EventData_GameStartedEvent,
    EventData_RoundPurchaseStartedEvent,
    EventData_RoundStartedEvent,
    EventData_RoundEndedEvent,
    EventData_PlayerKilledEvent,
    EventData_PlayerOpenFireEvent,
    EventData_BombPlantedEvent,
    EventData_BombDefusedEvent,
    EventData_ChatMessageEvent,
    EventData_GameEndedEvent,
    EventData_PurchaseEvent
  };
  return values;
}

inline const char * const *EnumNamesEventData() {
  static const char * const names[15] = {
    "NONE",
    "PlayerJoinedEvent",
    "PlayerLeftEvent",
    "GameStartedEvent",
    "RoundPurchaseStartedEvent",
    "RoundStartedEvent",
    "RoundEndedEvent",
    "PlayerKilledEvent",
    "PlayerOpenFireEvent",
    "BombPlantedEvent",
    "BombDefusedEvent",
    "ChatMessageEvent",
    "GameEndedEvent",
    "PurchaseEvent",
    nullptr
  };
  return names;
}

inline const char *EnumNameEventData(EventData e) {
  if (::flatbuffers::IsOutRange(e, EventData_NONE, EventData_PurchaseEvent)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEventData()[index];
}

template<typename T> struct EventDataTraits {
  static const EventData enum_value = EventData_NONE;
};

template<> struct EventDataTraits<moe::net::PlayerJoinedEvent> {
  static const EventData enum_value = EventData_PlayerJoinedEvent;
};

template<> struct EventDataTraits<moe::net::PlayerLeftEvent> {
  static const EventData enum_value = EventData_PlayerLeftEvent;
};

template<> struct EventDataTraits<moe::net::GameStartedEvent> {
  static const EventData enum_value = EventData_GameStartedEvent;
};

template<> struct EventDataTraits<moe::net::RoundPurchaseStartedEvent> {
  static const EventData enum_value = EventData_RoundPurchaseStartedEvent;
};

template<> struct EventDataTraits<moe::net::RoundStartedEvent> {
  static const EventData enum_value = EventData_RoundStartedEvent;
};

template<> struct EventDataTraits<moe::net::RoundEndedEvent> {
  static const EventData enum_value = EventData_RoundEndedEvent;
};

template<> struct EventDataTraits<moe::net::PlayerKilledEvent> {
  static const EventData enum_value = EventData_PlayerKilledEvent;
};

template<> struct EventDataTraits<moe::net::PlayerOpenFireEvent> {
  static const EventData enum_value = EventData_PlayerOpenFireEvent;
};

template<> struct EventDataTraits<moe::net::BombPlantedEvent> {
  static const EventData enum_value = EventData_BombPlantedEvent;
};

template<> struct EventDataTraits<moe::net::BombDefusedEvent> {
  static const EventData enum_value = EventData_BombDefusedEvent;
};

template<> struct EventDataTraits<moe::net::ChatMessageEvent> {
  static const EventData enum_value = EventData_ChatMessageEvent;
};

template<> struct EventDataTraits<moe::net::GameEndedEvent> {
  static const EventData enum_value = EventData_GameEndedEvent;
};

template<> struct EventDataTraits<moe::net::PurchaseEvent> {
  static const EventData enum_value = EventData_PurchaseEvent;
};

bool VerifyEventData(::flatbuffers::Verifier &verifier, const void *obj, EventData type);
bool VerifyEventDataVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

struct PlayerJoinedEvent FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PlayerJoinedEventBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UUID = 4,
    VT_NAME = 6,
    VT_PLAYERCOUNT = 8
  };
  const ::flatbuffers::String *uuid() const {
    return GetPointer<const ::flatbuffers::String *>(VT_UUID);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  uint16_t playerCount() const {
    return GetField<uint16_t>(VT_PLAYERCOUNT, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_UUID) &&
           verifier.VerifyString(uuid()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint16_t>(verifier, VT_PLAYERCOUNT, 2) &&
           verifier.EndTable();
  }
};

struct PlayerJoinedEventBuilder {
  typedef PlayerJoinedEvent Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_uuid(::flatbuffers::Offset<::flatbuffers::String> uuid) {
    fbb_.AddOffset(PlayerJoinedEvent::VT_UUID, uuid);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(PlayerJoinedEvent::VT_NAME, name);
  }
  void add_playerCount(uint16_t playerCount) {
    fbb_.AddElement<uint16_t>(PlayerJoinedEvent::VT_PLAYERCOUNT, playerCount, 0);
  }
  explicit PlayerJoinedEventBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PlayerJoinedEvent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PlayerJoinedEvent>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PlayerJoinedEvent> CreatePlayerJoinedEvent(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> uuid = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    uint16_t playerCount = 0) {
  PlayerJoinedEventBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_uuid(uuid);
  builder_.add_playerCount(playerCount);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PlayerJoinedEvent> CreatePlayerJoinedEventDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *uuid = nullptr,
    const char *name = nullptr,
    uint16_t playerCount = 0) {
  auto uuid__ = uuid ? _fbb.CreateString(uuid) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return moe::net::CreatePlayerJoinedEvent(
      _fbb,
      uuid__,
      name__,
      playerCount);
}

struct PlayerLeftEvent FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PlayerLeftEventBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UUID = 4,
    VT_NAME = 6,
    VT_PLAYERCOUNT = 8
  };
  const ::flatbuffers::String *uuid() const {
    return GetPointer<const ::flatbuffers::String *>(VT_UUID);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  uint16_t playerCount() const {
    return GetField<uint16_t>(VT_PLAYERCOUNT, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_UUID) &&
           verifier.VerifyString(uuid()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint16_t>(verifier, VT_PLAYERCOUNT, 2) &&
           verifier.EndTable();
  }
};

struct PlayerLeftEventBuilder {
  typedef PlayerLeftEvent Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_uuid(::flatbuffers::Offset<::flatbuffers::String> uuid) {
    fbb_.AddOffset(PlayerLeftEvent::VT_UUID, uuid);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(PlayerLeftEvent::VT_NAME, name);
  }
  void add_playerCount(uint16_t playerCount) {
    fbb_.AddElement<uint16_t>(PlayerLeftEvent::VT_PLAYERCOUNT, playerCount, 0);
  }
  explicit PlayerLeftEventBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PlayerLeftEvent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PlayerLeftEvent>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PlayerLeftEvent> CreatePlayerLeftEvent(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> uuid = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    uint16_t playerCount = 0) {
  PlayerLeftEventBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_uuid(uuid);
  builder_.add_playerCount(playerCount);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PlayerLeftEvent> CreatePlayerLeftEventDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *uuid = nullptr,
    const char *name = nullptr,
    uint16_t playerCount = 0) {
  auto uuid__ = uuid ? _fbb.CreateString(uuid) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return moe::net::CreatePlayerLeftEvent(
      _fbb,
      uuid__,
      name__,
      playerCount);
}

struct GameStartedEvent FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GameStartedEventBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLAYERS = 4
  };
  const moe::net::AllPlayerInfo *players() const {
    return GetPointer<const moe::net::AllPlayerInfo *>(VT_PLAYERS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PLAYERS) &&
           verifier.VerifyTable(players()) &&
           verifier.EndTable();
  }
};

struct GameStartedEventBuilder {
  typedef GameStartedEvent Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_players(::flatbuffers::Offset<moe::net::AllPlayerInfo> players) {
    fbb_.AddOffset(GameStartedEvent::VT_PLAYERS, players);
  }
  explicit GameStartedEventBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GameStartedEvent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GameStartedEvent>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GameStartedEvent> CreateGameStartedEvent(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<moe::net::AllPlayerInfo> players = 0) {
  GameStartedEventBuilder builder_(_fbb);
  builder_.add_players(players);
  return builder_.Finish();
}

struct RoundPurchaseStartedEvent FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RoundPurchaseStartedEventBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ROUNDNUMBER = 4,
    VT_BALANCE = 6
  };
  uint16_t roundNumber() const {
    return GetField<uint16_t>(VT_ROUNDNUMBER, 0);
  }
  uint32_t balance() const {
    return GetField<uint32_t>(VT_BALANCE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ROUNDNUMBER, 2) &&
           VerifyField<uint32_t>(verifier, VT_BALANCE, 4) &&
           verifier.EndTable();
  }
};

struct RoundPurchaseStartedEventBuilder {
  typedef RoundPurchaseStartedEvent Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_roundNumber(uint16_t roundNumber) {
    fbb_.AddElement<uint16_t>(RoundPurchaseStartedEvent::VT_ROUNDNUMBER, roundNumber, 0);
  }
  void add_balance(uint32_t balance) {
    fbb_.AddElement<uint32_t>(RoundPurchaseStartedEvent::VT_BALANCE, balance, 0);
  }
  explicit RoundPurchaseStartedEventBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RoundPurchaseStartedEvent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RoundPurchaseStartedEvent>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RoundPurchaseStartedEvent> CreateRoundPurchaseStartedEvent(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t roundNumber = 0,
    uint32_t balance = 0) {
  RoundPurchaseStartedEventBuilder builder_(_fbb);
  builder_.add_balance(balance);
  builder_.add_roundNumber(roundNumber);
  return builder_.Finish();
}

struct RoundStartedEvent FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RoundStartedEventBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ROUNDNUMBER = 4
  };
  uint16_t roundNumber() const {
    return GetField<uint16_t>(VT_ROUNDNUMBER, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ROUNDNUMBER, 2) &&
           verifier.EndTable();
  }
};

struct RoundStartedEventBuilder {
  typedef RoundStartedEvent Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_roundNumber(uint16_t roundNumber) {
    fbb_.AddElement<uint16_t>(RoundStartedEvent::VT_ROUNDNUMBER, roundNumber, 0);
  }
  explicit RoundStartedEventBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RoundStartedEvent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RoundStartedEvent>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RoundStartedEvent> CreateRoundStartedEvent(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t roundNumber = 0) {
  RoundStartedEventBuilder builder_(_fbb);
  builder_.add_roundNumber(roundNumber);
  return builder_.Finish();
}

struct RoundEndedEvent FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RoundEndedEventBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ROUNDNUMBER = 4,
    VT_WINNINGTEAM = 6
  };
  uint16_t roundNumber() const {
    return GetField<uint16_t>(VT_ROUNDNUMBER, 0);
  }
  moe::net::PlayerTeam winningTeam() const {
    return static_cast<moe::net::PlayerTeam>(GetField<int8_t>(VT_WINNINGTEAM, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ROUNDNUMBER, 2) &&
           VerifyField<int8_t>(verifier, VT_WINNINGTEAM, 1) &&
           verifier.EndTable();
  }
};

struct RoundEndedEventBuilder {
  typedef RoundEndedEvent Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_roundNumber(uint16_t roundNumber) {
    fbb_.AddElement<uint16_t>(RoundEndedEvent::VT_ROUNDNUMBER, roundNumber, 0);
  }
  void add_winningTeam(moe::net::PlayerTeam winningTeam) {
    fbb_.AddElement<int8_t>(RoundEndedEvent::VT_WINNINGTEAM, static_cast<int8_t>(winningTeam), 0);
  }
  explicit RoundEndedEventBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RoundEndedEvent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RoundEndedEvent>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RoundEndedEvent> CreateRoundEndedEvent(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t roundNumber = 0,
    moe::net::PlayerTeam winningTeam = moe::net::PlayerTeam_TEAM_NONE) {
  RoundEndedEventBuilder builder_(_fbb);
  builder_.add_roundNumber(roundNumber);
  builder_.add_winningTeam(winningTeam);
  return builder_.Finish();
}

struct PlayerKilledEvent FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PlayerKilledEventBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VICTIMTEMPID = 4,
    VT_KILLERTEMPID = 6,
    VT_WEAPON = 8
  };
  uint16_t victimTempId() const {
    return GetField<uint16_t>(VT_VICTIMTEMPID, 0);
  }
  uint16_t killerTempId() const {
    return GetField<uint16_t>(VT_KILLERTEMPID, 0);
  }
  moe::net::Weapon weapon() const {
    return static_cast<moe::net::Weapon>(GetField<int8_t>(VT_WEAPON, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_VICTIMTEMPID, 2) &&
           VerifyField<uint16_t>(verifier, VT_KILLERTEMPID, 2) &&
           VerifyField<int8_t>(verifier, VT_WEAPON, 1) &&
           verifier.EndTable();
  }
};

struct PlayerKilledEventBuilder {
  typedef PlayerKilledEvent Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_victimTempId(uint16_t victimTempId) {
    fbb_.AddElement<uint16_t>(PlayerKilledEvent::VT_VICTIMTEMPID, victimTempId, 0);
  }
  void add_killerTempId(uint16_t killerTempId) {
    fbb_.AddElement<uint16_t>(PlayerKilledEvent::VT_KILLERTEMPID, killerTempId, 0);
  }
  void add_weapon(moe::net::Weapon weapon) {
    fbb_.AddElement<int8_t>(PlayerKilledEvent::VT_WEAPON, static_cast<int8_t>(weapon), 0);
  }
  explicit PlayerKilledEventBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PlayerKilledEvent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PlayerKilledEvent>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PlayerKilledEvent> CreatePlayerKilledEvent(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t victimTempId = 0,
    uint16_t killerTempId = 0,
    moe::net::Weapon weapon = moe::net::Weapon_WEAPON_NONE) {
  PlayerKilledEventBuilder builder_(_fbb);
  builder_.add_killerTempId(killerTempId);
  builder_.add_victimTempId(victimTempId);
  builder_.add_weapon(weapon);
  return builder_.Finish();
}

struct PlayerOpenFireEvent FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PlayerOpenFireEventBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SHOOTERTEMPID = 4,
    VT_POSX = 6,
    VT_POSY = 8,
    VT_POSZ = 10
  };
  uint16_t shooterTempId() const {
    return GetField<uint16_t>(VT_SHOOTERTEMPID, 0);
  }
  float posX() const {
    return GetField<float>(VT_POSX, 0.0f);
  }
  float posY() const {
    return GetField<float>(VT_POSY, 0.0f);
  }
  float posZ() const {
    return GetField<float>(VT_POSZ, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_SHOOTERTEMPID, 2) &&
           VerifyField<float>(verifier, VT_POSX, 4) &&
           VerifyField<float>(verifier, VT_POSY, 4) &&
           VerifyField<float>(verifier, VT_POSZ, 4) &&
           verifier.EndTable();
  }
};

struct PlayerOpenFireEventBuilder {
  typedef PlayerOpenFireEvent Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_shooterTempId(uint16_t shooterTempId) {
    fbb_.AddElement<uint16_t>(PlayerOpenFireEvent::VT_SHOOTERTEMPID, shooterTempId, 0);
  }
  void add_posX(float posX) {
    fbb_.AddElement<float>(PlayerOpenFireEvent::VT_POSX, posX, 0.0f);
  }
  void add_posY(float posY) {
    fbb_.AddElement<float>(PlayerOpenFireEvent::VT_POSY, posY, 0.0f);
  }
  void add_posZ(float posZ) {
    fbb_.AddElement<float>(PlayerOpenFireEvent::VT_POSZ, posZ, 0.0f);
  }
  explicit PlayerOpenFireEventBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PlayerOpenFireEvent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PlayerOpenFireEvent>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PlayerOpenFireEvent> CreatePlayerOpenFireEvent(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t shooterTempId = 0,
    float posX = 0.0f,
    float posY = 0.0f,
    float posZ = 0.0f) {
  PlayerOpenFireEventBuilder builder_(_fbb);
  builder_.add_posZ(posZ);
  builder_.add_posY(posY);
  builder_.add_posX(posX);
  builder_.add_shooterTempId(shooterTempId);
  return builder_.Finish();
}

struct BombPlantedEvent FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BombPlantedEventBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLANTERTEMPID = 4,
    VT_BOMBSITE = 6
  };
  uint16_t planterTempId() const {
    return GetField<uint16_t>(VT_PLANTERTEMPID, 0);
  }
  uint16_t bombSite() const {
    return GetField<uint16_t>(VT_BOMBSITE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_PLANTERTEMPID, 2) &&
           VerifyField<uint16_t>(verifier, VT_BOMBSITE, 2) &&
           verifier.EndTable();
  }
};

struct BombPlantedEventBuilder {
  typedef BombPlantedEvent Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_planterTempId(uint16_t planterTempId) {
    fbb_.AddElement<uint16_t>(BombPlantedEvent::VT_PLANTERTEMPID, planterTempId, 0);
  }
  void add_bombSite(uint16_t bombSite) {
    fbb_.AddElement<uint16_t>(BombPlantedEvent::VT_BOMBSITE, bombSite, 0);
  }
  explicit BombPlantedEventBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BombPlantedEvent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BombPlantedEvent>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BombPlantedEvent> CreateBombPlantedEvent(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t planterTempId = 0,
    uint16_t bombSite = 0) {
  BombPlantedEventBuilder builder_(_fbb);
  builder_.add_bombSite(bombSite);
  builder_.add_planterTempId(planterTempId);
  return builder_.Finish();
}

struct BombDefusedEvent FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BombDefusedEventBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DEFUSERTEMPID = 4
  };
  uint16_t defuserTempId() const {
    return GetField<uint16_t>(VT_DEFUSERTEMPID, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_DEFUSERTEMPID, 2) &&
           verifier.EndTable();
  }
};

struct BombDefusedEventBuilder {
  typedef BombDefusedEvent Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_defuserTempId(uint16_t defuserTempId) {
    fbb_.AddElement<uint16_t>(BombDefusedEvent::VT_DEFUSERTEMPID, defuserTempId, 0);
  }
  explicit BombDefusedEventBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BombDefusedEvent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BombDefusedEvent>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BombDefusedEvent> CreateBombDefusedEvent(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t defuserTempId = 0) {
  BombDefusedEventBuilder builder_(_fbb);
  builder_.add_defuserTempId(defuserTempId);
  return builder_.Finish();
}

struct ChatMessageEvent FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ChatMessageEventBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SENDERTEMPID = 4,
    VT_MESSAGE = 6
  };
  uint16_t senderTempId() const {
    return GetField<uint16_t>(VT_SENDERTEMPID, 0);
  }
  const ::flatbuffers::String *message() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MESSAGE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_SENDERTEMPID, 2) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           verifier.EndTable();
  }
};

struct ChatMessageEventBuilder {
  typedef ChatMessageEvent Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_senderTempId(uint16_t senderTempId) {
    fbb_.AddElement<uint16_t>(ChatMessageEvent::VT_SENDERTEMPID, senderTempId, 0);
  }
  void add_message(::flatbuffers::Offset<::flatbuffers::String> message) {
    fbb_.AddOffset(ChatMessageEvent::VT_MESSAGE, message);
  }
  explicit ChatMessageEventBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ChatMessageEvent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ChatMessageEvent>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ChatMessageEvent> CreateChatMessageEvent(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t senderTempId = 0,
    ::flatbuffers::Offset<::flatbuffers::String> message = 0) {
  ChatMessageEventBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_senderTempId(senderTempId);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ChatMessageEvent> CreateChatMessageEventDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t senderTempId = 0,
    const char *message = nullptr) {
  auto message__ = message ? _fbb.CreateString(message) : 0;
  return moe::net::CreateChatMessageEvent(
      _fbb,
      senderTempId,
      message__);
}

struct GameEndedEvent FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GameEndedEventBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REASON = 4,
    VT_WINNER = 6
  };
  const ::flatbuffers::String *reason() const {
    return GetPointer<const ::flatbuffers::String *>(VT_REASON);
  }
  moe::net::PlayerTeam winner() const {
    return static_cast<moe::net::PlayerTeam>(GetField<int8_t>(VT_WINNER, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_REASON) &&
           verifier.VerifyString(reason()) &&
           VerifyField<int8_t>(verifier, VT_WINNER, 1) &&
           verifier.EndTable();
  }
};

struct GameEndedEventBuilder {
  typedef GameEndedEvent Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_reason(::flatbuffers::Offset<::flatbuffers::String> reason) {
    fbb_.AddOffset(GameEndedEvent::VT_REASON, reason);
  }
  void add_winner(moe::net::PlayerTeam winner) {
    fbb_.AddElement<int8_t>(GameEndedEvent::VT_WINNER, static_cast<int8_t>(winner), 0);
  }
  explicit GameEndedEventBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GameEndedEvent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GameEndedEvent>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GameEndedEvent> CreateGameEndedEvent(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> reason = 0,
    moe::net::PlayerTeam winner = moe::net::PlayerTeam_TEAM_NONE) {
  GameEndedEventBuilder builder_(_fbb);
  builder_.add_reason(reason);
  builder_.add_winner(winner);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<GameEndedEvent> CreateGameEndedEventDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *reason = nullptr,
    moe::net::PlayerTeam winner = moe::net::PlayerTeam_TEAM_NONE) {
  auto reason__ = reason ? _fbb.CreateString(reason) : 0;
  return moe::net::CreateGameEndedEvent(
      _fbb,
      reason__,
      winner);
}

struct PurchaseEvent FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PurchaseEventBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PRIMARYWEAPON = 4,
    VT_SECONDARYWEAPON = 6,
    VT_SUCCESS = 8,
    VT_BALANCE = 10
  };
  moe::net::Weapon primaryWeapon() const {
    return static_cast<moe::net::Weapon>(GetField<int8_t>(VT_PRIMARYWEAPON, 0));
  }
  moe::net::Weapon secondaryWeapon() const {
    return static_cast<moe::net::Weapon>(GetField<int8_t>(VT_SECONDARYWEAPON, 0));
  }
  bool success() const {
    return GetField<uint8_t>(VT_SUCCESS, 0) != 0;
  }
  uint32_t balance() const {
    return GetField<uint32_t>(VT_BALANCE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_PRIMARYWEAPON, 1) &&
           VerifyField<int8_t>(verifier, VT_SECONDARYWEAPON, 1) &&
           VerifyField<uint8_t>(verifier, VT_SUCCESS, 1) &&
           VerifyField<uint32_t>(verifier, VT_BALANCE, 4) &&
           verifier.EndTable();
  }
};

struct PurchaseEventBuilder {
  typedef PurchaseEvent Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_primaryWeapon(moe::net::Weapon primaryWeapon) {
    fbb_.AddElement<int8_t>(PurchaseEvent::VT_PRIMARYWEAPON, static_cast<int8_t>(primaryWeapon), 0);
  }
  void add_secondaryWeapon(moe::net::Weapon secondaryWeapon) {
    fbb_.AddElement<int8_t>(PurchaseEvent::VT_SECONDARYWEAPON, static_cast<int8_t>(secondaryWeapon), 0);
  }
  void add_success(bool success) {
    fbb_.AddElement<uint8_t>(PurchaseEvent::VT_SUCCESS, static_cast<uint8_t>(success), 0);
  }
  void add_balance(uint32_t balance) {
    fbb_.AddElement<uint32_t>(PurchaseEvent::VT_BALANCE, balance, 0);
  }
  explicit PurchaseEventBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PurchaseEvent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PurchaseEvent>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PurchaseEvent> CreatePurchaseEvent(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    moe::net::Weapon primaryWeapon = moe::net::Weapon_WEAPON_NONE,
    moe::net::Weapon secondaryWeapon = moe::net::Weapon_WEAPON_NONE,
    bool success = false,
    uint32_t balance = 0) {
  PurchaseEventBuilder builder_(_fbb);
  builder_.add_balance(balance);
  builder_.add_success(success);
  builder_.add_secondaryWeapon(secondaryWeapon);
  builder_.add_primaryWeapon(primaryWeapon);
  return builder_.Finish();
}

struct GameEvent FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GameEventBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PAYLOAD_TYPE = 4,
    VT_PAYLOAD = 6
  };
  moe::net::EventData payload_type() const {
    return static_cast<moe::net::EventData>(GetField<uint8_t>(VT_PAYLOAD_TYPE, 0));
  }
  const void *payload() const {
    return GetPointer<const void *>(VT_PAYLOAD);
  }
  template<typename T> const T *payload_as() const;
  const moe::net::PlayerJoinedEvent *payload_as_PlayerJoinedEvent() const {
    return payload_type() == moe::net::EventData_PlayerJoinedEvent ? static_cast<const moe::net::PlayerJoinedEvent *>(payload()) : nullptr;
  }
  const moe::net::PlayerLeftEvent *payload_as_PlayerLeftEvent() const {
    return payload_type() == moe::net::EventData_PlayerLeftEvent ? static_cast<const moe::net::PlayerLeftEvent *>(payload()) : nullptr;
  }
  const moe::net::GameStartedEvent *payload_as_GameStartedEvent() const {
    return payload_type() == moe::net::EventData_GameStartedEvent ? static_cast<const moe::net::GameStartedEvent *>(payload()) : nullptr;
  }
  const moe::net::RoundPurchaseStartedEvent *payload_as_RoundPurchaseStartedEvent() const {
    return payload_type() == moe::net::EventData_RoundPurchaseStartedEvent ? static_cast<const moe::net::RoundPurchaseStartedEvent *>(payload()) : nullptr;
  }
  const moe::net::RoundStartedEvent *payload_as_RoundStartedEvent() const {
    return payload_type() == moe::net::EventData_RoundStartedEvent ? static_cast<const moe::net::RoundStartedEvent *>(payload()) : nullptr;
  }
  const moe::net::RoundEndedEvent *payload_as_RoundEndedEvent() const {
    return payload_type() == moe::net::EventData_RoundEndedEvent ? static_cast<const moe::net::RoundEndedEvent *>(payload()) : nullptr;
  }
  const moe::net::PlayerKilledEvent *payload_as_PlayerKilledEvent() const {
    return payload_type() == moe::net::EventData_PlayerKilledEvent ? static_cast<const moe::net::PlayerKilledEvent *>(payload()) : nullptr;
  }
  const moe::net::PlayerOpenFireEvent *payload_as_PlayerOpenFireEvent() const {
    return payload_type() == moe::net::EventData_PlayerOpenFireEvent ? static_cast<const moe::net::PlayerOpenFireEvent *>(payload()) : nullptr;
  }
  const moe::net::BombPlantedEvent *payload_as_BombPlantedEvent() const {
    return payload_type() == moe::net::EventData_BombPlantedEvent ? static_cast<const moe::net::BombPlantedEvent *>(payload()) : nullptr;
  }
  const moe::net::BombDefusedEvent *payload_as_BombDefusedEvent() const {
    return payload_type() == moe::net::EventData_BombDefusedEvent ? static_cast<const moe::net::BombDefusedEvent *>(payload()) : nullptr;
  }
  const moe::net::ChatMessageEvent *payload_as_ChatMessageEvent() const {
    return payload_type() == moe::net::EventData_ChatMessageEvent ? static_cast<const moe::net::ChatMessageEvent *>(payload()) : nullptr;
  }
  const moe::net::GameEndedEvent *payload_as_GameEndedEvent() const {
    return payload_type() == moe::net::EventData_GameEndedEvent ? static_cast<const moe::net::GameEndedEvent *>(payload()) : nullptr;
  }
  const moe::net::PurchaseEvent *payload_as_PurchaseEvent() const {
    return payload_type() == moe::net::EventData_PurchaseEvent ? static_cast<const moe::net::PurchaseEvent *>(payload()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_PAYLOAD_TYPE, 1) &&
           VerifyOffset(verifier, VT_PAYLOAD) &&
           VerifyEventData(verifier, payload(), payload_type()) &&
           verifier.EndTable();
  }
};

template<> inline const moe::net::PlayerJoinedEvent *GameEvent::payload_as<moe::net::PlayerJoinedEvent>() const {
  return payload_as_PlayerJoinedEvent();
}

template<> inline const moe::net::PlayerLeftEvent *GameEvent::payload_as<moe::net::PlayerLeftEvent>() const {
  return payload_as_PlayerLeftEvent();
}

template<> inline const moe::net::GameStartedEvent *GameEvent::payload_as<moe::net::GameStartedEvent>() const {
  return payload_as_GameStartedEvent();
}

template<> inline const moe::net::RoundPurchaseStartedEvent *GameEvent::payload_as<moe::net::RoundPurchaseStartedEvent>() const {
  return payload_as_RoundPurchaseStartedEvent();
}

template<> inline const moe::net::RoundStartedEvent *GameEvent::payload_as<moe::net::RoundStartedEvent>() const {
  return payload_as_RoundStartedEvent();
}

template<> inline const moe::net::RoundEndedEvent *GameEvent::payload_as<moe::net::RoundEndedEvent>() const {
  return payload_as_RoundEndedEvent();
}

template<> inline const moe::net::PlayerKilledEvent *GameEvent::payload_as<moe::net::PlayerKilledEvent>() const {
  return payload_as_PlayerKilledEvent();
}

template<> inline const moe::net::PlayerOpenFireEvent *GameEvent::payload_as<moe::net::PlayerOpenFireEvent>() const {
  return payload_as_PlayerOpenFireEvent();
}

template<> inline const moe::net::BombPlantedEvent *GameEvent::payload_as<moe::net::BombPlantedEvent>() const {
  return payload_as_BombPlantedEvent();
}

template<> inline const moe::net::BombDefusedEvent *GameEvent::payload_as<moe::net::BombDefusedEvent>() const {
  return payload_as_BombDefusedEvent();
}

template<> inline const moe::net::ChatMessageEvent *GameEvent::payload_as<moe::net::ChatMessageEvent>() const {
  return payload_as_ChatMessageEvent();
}

template<> inline const moe::net::GameEndedEvent *GameEvent::payload_as<moe::net::GameEndedEvent>() const {
  return payload_as_GameEndedEvent();
}

template<> inline const moe::net::PurchaseEvent *GameEvent::payload_as<moe::net::PurchaseEvent>() const {
  return payload_as_PurchaseEvent();
}

struct GameEventBuilder {
  typedef GameEvent Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_payload_type(moe::net::EventData payload_type) {
    fbb_.AddElement<uint8_t>(GameEvent::VT_PAYLOAD_TYPE, static_cast<uint8_t>(payload_type), 0);
  }
  void add_payload(::flatbuffers::Offset<void> payload) {
    fbb_.AddOffset(GameEvent::VT_PAYLOAD, payload);
  }
  explicit GameEventBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GameEvent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GameEvent>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GameEvent> CreateGameEvent(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    moe::net::EventData payload_type = moe::net::EventData_NONE,
    ::flatbuffers::Offset<void> payload = 0) {
  GameEventBuilder builder_(_fbb);
  builder_.add_payload(payload);
  builder_.add_payload_type(payload_type);
  return builder_.Finish();
}

inline bool VerifyEventData(::flatbuffers::Verifier &verifier, const void *obj, EventData type) {
  switch (type) {
    case EventData_NONE: {
      return true;
    }
    case EventData_PlayerJoinedEvent: {
      auto ptr = reinterpret_cast<const moe::net::PlayerJoinedEvent *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case EventData_PlayerLeftEvent: {
      auto ptr = reinterpret_cast<const moe::net::PlayerLeftEvent *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case EventData_GameStartedEvent: {
      auto ptr = reinterpret_cast<const moe::net::GameStartedEvent *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case EventData_RoundPurchaseStartedEvent: {
      auto ptr = reinterpret_cast<const moe::net::RoundPurchaseStartedEvent *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case EventData_RoundStartedEvent: {
      auto ptr = reinterpret_cast<const moe::net::RoundStartedEvent *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case EventData_RoundEndedEvent: {
      auto ptr = reinterpret_cast<const moe::net::RoundEndedEvent *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case EventData_PlayerKilledEvent: {
      auto ptr = reinterpret_cast<const moe::net::PlayerKilledEvent *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case EventData_PlayerOpenFireEvent: {
      auto ptr = reinterpret_cast<const moe::net::PlayerOpenFireEvent *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case EventData_BombPlantedEvent: {
      auto ptr = reinterpret_cast<const moe::net::BombPlantedEvent *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case EventData_BombDefusedEvent: {
      auto ptr = reinterpret_cast<const moe::net::BombDefusedEvent *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case EventData_ChatMessageEvent: {
      auto ptr = reinterpret_cast<const moe::net::ChatMessageEvent *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case EventData_GameEndedEvent: {
      auto ptr = reinterpret_cast<const moe::net::GameEndedEvent *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case EventData_PurchaseEvent: {
      auto ptr = reinterpret_cast<const moe::net::PurchaseEvent *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyEventDataVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyEventData(
        verifier,  values->Get(i), types->GetEnum<EventData>(i))) {
      return false;
    }
  }
  return true;
}

}  // namespace net
}  // namespace moe

#endif  // FLATBUFFERS_GENERATED_EVENTS_MOE_NET_H_
