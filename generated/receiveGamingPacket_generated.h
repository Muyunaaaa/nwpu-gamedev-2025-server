// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_RECEIVEGAMINGPACKET_MYU_NET_H_
#define FLATBUFFERS_GENERATED_RECEIVEGAMINGPACKET_MYU_NET_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 9 &&
              FLATBUFFERS_VERSION_REVISION == 23,
             "Non-compatible flatbuffers version included");

namespace myu {
namespace net {

struct PacketHeader;
struct PacketHeaderBuilder;

struct FirePacket;
struct FirePacketBuilder;

struct MovePacket;
struct MovePacketBuilder;

struct PlayerStatePacket;
struct PlayerStatePacketBuilder;

struct NetMessage;
struct NetMessageBuilder;

enum PacketType : int8_t {
  PacketType_PLAYER_STATE = 0,
  PacketType_FIRE = 1,
  PacketType_MOVE = 2,
  PacketType_MIN = PacketType_PLAYER_STATE,
  PacketType_MAX = PacketType_MOVE
};

inline const PacketType (&EnumValuesPacketType())[3] {
  static const PacketType values[] = {
    PacketType_PLAYER_STATE,
    PacketType_FIRE,
    PacketType_MOVE
  };
  return values;
}

inline const char * const *EnumNamesPacketType() {
  static const char * const names[4] = {
    "PLAYER_STATE",
    "FIRE",
    "MOVE",
    nullptr
  };
  return names;
}

inline const char *EnumNamePacketType(PacketType e) {
  if (::flatbuffers::IsOutRange(e, PacketType_PLAYER_STATE, PacketType_MOVE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPacketType()[index];
}

enum PacketUnion : uint8_t {
  PacketUnion_NONE = 0,
  PacketUnion_FirePacket = 1,
  PacketUnion_MovePacket = 2,
  PacketUnion_PlayerStatePacket = 3,
  PacketUnion_MIN = PacketUnion_NONE,
  PacketUnion_MAX = PacketUnion_PlayerStatePacket
};

inline const PacketUnion (&EnumValuesPacketUnion())[4] {
  static const PacketUnion values[] = {
    PacketUnion_NONE,
    PacketUnion_FirePacket,
    PacketUnion_MovePacket,
    PacketUnion_PlayerStatePacket
  };
  return values;
}

inline const char * const *EnumNamesPacketUnion() {
  static const char * const names[5] = {
    "NONE",
    "FirePacket",
    "MovePacket",
    "PlayerStatePacket",
    nullptr
  };
  return names;
}

inline const char *EnumNamePacketUnion(PacketUnion e) {
  if (::flatbuffers::IsOutRange(e, PacketUnion_NONE, PacketUnion_PlayerStatePacket)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPacketUnion()[index];
}

template<typename T> struct PacketUnionTraits {
  static const PacketUnion enum_value = PacketUnion_NONE;
};

template<> struct PacketUnionTraits<myu::net::FirePacket> {
  static const PacketUnion enum_value = PacketUnion_FirePacket;
};

template<> struct PacketUnionTraits<myu::net::MovePacket> {
  static const PacketUnion enum_value = PacketUnion_MovePacket;
};

template<> struct PacketUnionTraits<myu::net::PlayerStatePacket> {
  static const PacketUnion enum_value = PacketUnion_PlayerStatePacket;
};

bool VerifyPacketUnion(::flatbuffers::Verifier &verifier, const void *obj, PacketUnion type);
bool VerifyPacketUnionVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

struct PacketHeader FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PacketHeaderBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_CLIENT_TICK = 6,
    VT_CLIENT_TIME = 8
  };
  myu::net::PacketType type() const {
    return static_cast<myu::net::PacketType>(GetField<int8_t>(VT_TYPE, 0));
  }
  uint32_t client_tick() const {
    return GetField<uint32_t>(VT_CLIENT_TICK, 0);
  }
  uint64_t client_time() const {
    return GetField<uint64_t>(VT_CLIENT_TIME, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE, 1) &&
           VerifyField<uint32_t>(verifier, VT_CLIENT_TICK, 4) &&
           VerifyField<uint64_t>(verifier, VT_CLIENT_TIME, 8) &&
           verifier.EndTable();
  }
};

struct PacketHeaderBuilder {
  typedef PacketHeader Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_type(myu::net::PacketType type) {
    fbb_.AddElement<int8_t>(PacketHeader::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_client_tick(uint32_t client_tick) {
    fbb_.AddElement<uint32_t>(PacketHeader::VT_CLIENT_TICK, client_tick, 0);
  }
  void add_client_time(uint64_t client_time) {
    fbb_.AddElement<uint64_t>(PacketHeader::VT_CLIENT_TIME, client_time, 0);
  }
  explicit PacketHeaderBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PacketHeader> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PacketHeader>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PacketHeader> CreatePacketHeader(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    myu::net::PacketType type = myu::net::PacketType_PLAYER_STATE,
    uint32_t client_tick = 0,
    uint64_t client_time = 0) {
  PacketHeaderBuilder builder_(_fbb);
  builder_.add_client_time(client_time);
  builder_.add_client_tick(client_tick);
  builder_.add_type(type);
  return builder_.Finish();
}

struct FirePacket FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FirePacketBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HEADER = 4,
    VT_PHYSICS_ID = 6,
    VT_FIRE_TICK = 8,
    VT_FIRE_TIME = 10,
    VT_ORIGIN_X = 12,
    VT_ORIGIN_Y = 14,
    VT_ORIGIN_Z = 16,
    VT_DIR_X = 18,
    VT_DIR_Y = 20,
    VT_DIR_Z = 22,
    VT_WEAPON_ID = 24,
    VT_SEQUENCE = 26
  };
  const myu::net::PacketHeader *header() const {
    return GetPointer<const myu::net::PacketHeader *>(VT_HEADER);
  }
  uint32_t physics_id() const {
    return GetField<uint32_t>(VT_PHYSICS_ID, 0);
  }
  uint32_t fire_tick() const {
    return GetField<uint32_t>(VT_FIRE_TICK, 0);
  }
  uint64_t fire_time() const {
    return GetField<uint64_t>(VT_FIRE_TIME, 0);
  }
  float origin_x() const {
    return GetField<float>(VT_ORIGIN_X, 0.0f);
  }
  float origin_y() const {
    return GetField<float>(VT_ORIGIN_Y, 0.0f);
  }
  float origin_z() const {
    return GetField<float>(VT_ORIGIN_Z, 0.0f);
  }
  float dir_x() const {
    return GetField<float>(VT_DIR_X, 0.0f);
  }
  float dir_y() const {
    return GetField<float>(VT_DIR_Y, 0.0f);
  }
  float dir_z() const {
    return GetField<float>(VT_DIR_Z, 0.0f);
  }
  uint16_t weapon_id() const {
    return GetField<uint16_t>(VT_WEAPON_ID, 0);
  }
  uint32_t sequence() const {
    return GetField<uint32_t>(VT_SEQUENCE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyField<uint32_t>(verifier, VT_PHYSICS_ID, 4) &&
           VerifyField<uint32_t>(verifier, VT_FIRE_TICK, 4) &&
           VerifyField<uint64_t>(verifier, VT_FIRE_TIME, 8) &&
           VerifyField<float>(verifier, VT_ORIGIN_X, 4) &&
           VerifyField<float>(verifier, VT_ORIGIN_Y, 4) &&
           VerifyField<float>(verifier, VT_ORIGIN_Z, 4) &&
           VerifyField<float>(verifier, VT_DIR_X, 4) &&
           VerifyField<float>(verifier, VT_DIR_Y, 4) &&
           VerifyField<float>(verifier, VT_DIR_Z, 4) &&
           VerifyField<uint16_t>(verifier, VT_WEAPON_ID, 2) &&
           VerifyField<uint32_t>(verifier, VT_SEQUENCE, 4) &&
           verifier.EndTable();
  }
};

struct FirePacketBuilder {
  typedef FirePacket Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_header(::flatbuffers::Offset<myu::net::PacketHeader> header) {
    fbb_.AddOffset(FirePacket::VT_HEADER, header);
  }
  void add_physics_id(uint32_t physics_id) {
    fbb_.AddElement<uint32_t>(FirePacket::VT_PHYSICS_ID, physics_id, 0);
  }
  void add_fire_tick(uint32_t fire_tick) {
    fbb_.AddElement<uint32_t>(FirePacket::VT_FIRE_TICK, fire_tick, 0);
  }
  void add_fire_time(uint64_t fire_time) {
    fbb_.AddElement<uint64_t>(FirePacket::VT_FIRE_TIME, fire_time, 0);
  }
  void add_origin_x(float origin_x) {
    fbb_.AddElement<float>(FirePacket::VT_ORIGIN_X, origin_x, 0.0f);
  }
  void add_origin_y(float origin_y) {
    fbb_.AddElement<float>(FirePacket::VT_ORIGIN_Y, origin_y, 0.0f);
  }
  void add_origin_z(float origin_z) {
    fbb_.AddElement<float>(FirePacket::VT_ORIGIN_Z, origin_z, 0.0f);
  }
  void add_dir_x(float dir_x) {
    fbb_.AddElement<float>(FirePacket::VT_DIR_X, dir_x, 0.0f);
  }
  void add_dir_y(float dir_y) {
    fbb_.AddElement<float>(FirePacket::VT_DIR_Y, dir_y, 0.0f);
  }
  void add_dir_z(float dir_z) {
    fbb_.AddElement<float>(FirePacket::VT_DIR_Z, dir_z, 0.0f);
  }
  void add_weapon_id(uint16_t weapon_id) {
    fbb_.AddElement<uint16_t>(FirePacket::VT_WEAPON_ID, weapon_id, 0);
  }
  void add_sequence(uint32_t sequence) {
    fbb_.AddElement<uint32_t>(FirePacket::VT_SEQUENCE, sequence, 0);
  }
  explicit FirePacketBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FirePacket> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FirePacket>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FirePacket> CreateFirePacket(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<myu::net::PacketHeader> header = 0,
    uint32_t physics_id = 0,
    uint32_t fire_tick = 0,
    uint64_t fire_time = 0,
    float origin_x = 0.0f,
    float origin_y = 0.0f,
    float origin_z = 0.0f,
    float dir_x = 0.0f,
    float dir_y = 0.0f,
    float dir_z = 0.0f,
    uint16_t weapon_id = 0,
    uint32_t sequence = 0) {
  FirePacketBuilder builder_(_fbb);
  builder_.add_fire_time(fire_time);
  builder_.add_sequence(sequence);
  builder_.add_dir_z(dir_z);
  builder_.add_dir_y(dir_y);
  builder_.add_dir_x(dir_x);
  builder_.add_origin_z(origin_z);
  builder_.add_origin_y(origin_y);
  builder_.add_origin_x(origin_x);
  builder_.add_fire_tick(fire_tick);
  builder_.add_physics_id(physics_id);
  builder_.add_header(header);
  builder_.add_weapon_id(weapon_id);
  return builder_.Finish();
}

struct MovePacket FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MovePacketBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HEADER = 4,
    VT_PHYSICS_ID = 6,
    VT_INPUT_TICK = 8,
    VT_MOVE_X = 10,
    VT_MOVE_Y = 12,
    VT_YAW = 14,
    VT_PITCH = 16,
    VT_JUMP = 18,
    VT_SPRINT = 20
  };
  const myu::net::PacketHeader *header() const {
    return GetPointer<const myu::net::PacketHeader *>(VT_HEADER);
  }
  uint32_t physics_id() const {
    return GetField<uint32_t>(VT_PHYSICS_ID, 0);
  }
  uint32_t input_tick() const {
    return GetField<uint32_t>(VT_INPUT_TICK, 0);
  }
  float move_x() const {
    return GetField<float>(VT_MOVE_X, 0.0f);
  }
  float move_y() const {
    return GetField<float>(VT_MOVE_Y, 0.0f);
  }
  float yaw() const {
    return GetField<float>(VT_YAW, 0.0f);
  }
  float pitch() const {
    return GetField<float>(VT_PITCH, 0.0f);
  }
  bool jump() const {
    return GetField<uint8_t>(VT_JUMP, 0) != 0;
  }
  bool sprint() const {
    return GetField<uint8_t>(VT_SPRINT, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyField<uint32_t>(verifier, VT_PHYSICS_ID, 4) &&
           VerifyField<uint32_t>(verifier, VT_INPUT_TICK, 4) &&
           VerifyField<float>(verifier, VT_MOVE_X, 4) &&
           VerifyField<float>(verifier, VT_MOVE_Y, 4) &&
           VerifyField<float>(verifier, VT_YAW, 4) &&
           VerifyField<float>(verifier, VT_PITCH, 4) &&
           VerifyField<uint8_t>(verifier, VT_JUMP, 1) &&
           VerifyField<uint8_t>(verifier, VT_SPRINT, 1) &&
           verifier.EndTable();
  }
};

struct MovePacketBuilder {
  typedef MovePacket Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_header(::flatbuffers::Offset<myu::net::PacketHeader> header) {
    fbb_.AddOffset(MovePacket::VT_HEADER, header);
  }
  void add_physics_id(uint32_t physics_id) {
    fbb_.AddElement<uint32_t>(MovePacket::VT_PHYSICS_ID, physics_id, 0);
  }
  void add_input_tick(uint32_t input_tick) {
    fbb_.AddElement<uint32_t>(MovePacket::VT_INPUT_TICK, input_tick, 0);
  }
  void add_move_x(float move_x) {
    fbb_.AddElement<float>(MovePacket::VT_MOVE_X, move_x, 0.0f);
  }
  void add_move_y(float move_y) {
    fbb_.AddElement<float>(MovePacket::VT_MOVE_Y, move_y, 0.0f);
  }
  void add_yaw(float yaw) {
    fbb_.AddElement<float>(MovePacket::VT_YAW, yaw, 0.0f);
  }
  void add_pitch(float pitch) {
    fbb_.AddElement<float>(MovePacket::VT_PITCH, pitch, 0.0f);
  }
  void add_jump(bool jump) {
    fbb_.AddElement<uint8_t>(MovePacket::VT_JUMP, static_cast<uint8_t>(jump), 0);
  }
  void add_sprint(bool sprint) {
    fbb_.AddElement<uint8_t>(MovePacket::VT_SPRINT, static_cast<uint8_t>(sprint), 0);
  }
  explicit MovePacketBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MovePacket> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MovePacket>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MovePacket> CreateMovePacket(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<myu::net::PacketHeader> header = 0,
    uint32_t physics_id = 0,
    uint32_t input_tick = 0,
    float move_x = 0.0f,
    float move_y = 0.0f,
    float yaw = 0.0f,
    float pitch = 0.0f,
    bool jump = false,
    bool sprint = false) {
  MovePacketBuilder builder_(_fbb);
  builder_.add_pitch(pitch);
  builder_.add_yaw(yaw);
  builder_.add_move_y(move_y);
  builder_.add_move_x(move_x);
  builder_.add_input_tick(input_tick);
  builder_.add_physics_id(physics_id);
  builder_.add_header(header);
  builder_.add_sprint(sprint);
  builder_.add_jump(jump);
  return builder_.Finish();
}

struct PlayerStatePacket FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PlayerStatePacketBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HEADER = 4,
    VT_PHYSICS_ID = 6,
    VT_POS_X = 8,
    VT_POS_Y = 10,
    VT_POS_Z = 12,
    VT_VEL_X = 14,
    VT_VEL_Y = 16,
    VT_VEL_Z = 18,
    VT_HEALTH = 20,
    VT_IS_ALIVE = 22
  };
  const myu::net::PacketHeader *header() const {
    return GetPointer<const myu::net::PacketHeader *>(VT_HEADER);
  }
  uint32_t physics_id() const {
    return GetField<uint32_t>(VT_PHYSICS_ID, 0);
  }
  float pos_x() const {
    return GetField<float>(VT_POS_X, 0.0f);
  }
  float pos_y() const {
    return GetField<float>(VT_POS_Y, 0.0f);
  }
  float pos_z() const {
    return GetField<float>(VT_POS_Z, 0.0f);
  }
  float vel_x() const {
    return GetField<float>(VT_VEL_X, 0.0f);
  }
  float vel_y() const {
    return GetField<float>(VT_VEL_Y, 0.0f);
  }
  float vel_z() const {
    return GetField<float>(VT_VEL_Z, 0.0f);
  }
  int16_t health() const {
    return GetField<int16_t>(VT_HEALTH, 0);
  }
  bool is_alive() const {
    return GetField<uint8_t>(VT_IS_ALIVE, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyField<uint32_t>(verifier, VT_PHYSICS_ID, 4) &&
           VerifyField<float>(verifier, VT_POS_X, 4) &&
           VerifyField<float>(verifier, VT_POS_Y, 4) &&
           VerifyField<float>(verifier, VT_POS_Z, 4) &&
           VerifyField<float>(verifier, VT_VEL_X, 4) &&
           VerifyField<float>(verifier, VT_VEL_Y, 4) &&
           VerifyField<float>(verifier, VT_VEL_Z, 4) &&
           VerifyField<int16_t>(verifier, VT_HEALTH, 2) &&
           VerifyField<uint8_t>(verifier, VT_IS_ALIVE, 1) &&
           verifier.EndTable();
  }
};

struct PlayerStatePacketBuilder {
  typedef PlayerStatePacket Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_header(::flatbuffers::Offset<myu::net::PacketHeader> header) {
    fbb_.AddOffset(PlayerStatePacket::VT_HEADER, header);
  }
  void add_physics_id(uint32_t physics_id) {
    fbb_.AddElement<uint32_t>(PlayerStatePacket::VT_PHYSICS_ID, physics_id, 0);
  }
  void add_pos_x(float pos_x) {
    fbb_.AddElement<float>(PlayerStatePacket::VT_POS_X, pos_x, 0.0f);
  }
  void add_pos_y(float pos_y) {
    fbb_.AddElement<float>(PlayerStatePacket::VT_POS_Y, pos_y, 0.0f);
  }
  void add_pos_z(float pos_z) {
    fbb_.AddElement<float>(PlayerStatePacket::VT_POS_Z, pos_z, 0.0f);
  }
  void add_vel_x(float vel_x) {
    fbb_.AddElement<float>(PlayerStatePacket::VT_VEL_X, vel_x, 0.0f);
  }
  void add_vel_y(float vel_y) {
    fbb_.AddElement<float>(PlayerStatePacket::VT_VEL_Y, vel_y, 0.0f);
  }
  void add_vel_z(float vel_z) {
    fbb_.AddElement<float>(PlayerStatePacket::VT_VEL_Z, vel_z, 0.0f);
  }
  void add_health(int16_t health) {
    fbb_.AddElement<int16_t>(PlayerStatePacket::VT_HEALTH, health, 0);
  }
  void add_is_alive(bool is_alive) {
    fbb_.AddElement<uint8_t>(PlayerStatePacket::VT_IS_ALIVE, static_cast<uint8_t>(is_alive), 0);
  }
  explicit PlayerStatePacketBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PlayerStatePacket> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PlayerStatePacket>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PlayerStatePacket> CreatePlayerStatePacket(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<myu::net::PacketHeader> header = 0,
    uint32_t physics_id = 0,
    float pos_x = 0.0f,
    float pos_y = 0.0f,
    float pos_z = 0.0f,
    float vel_x = 0.0f,
    float vel_y = 0.0f,
    float vel_z = 0.0f,
    int16_t health = 0,
    bool is_alive = false) {
  PlayerStatePacketBuilder builder_(_fbb);
  builder_.add_vel_z(vel_z);
  builder_.add_vel_y(vel_y);
  builder_.add_vel_x(vel_x);
  builder_.add_pos_z(pos_z);
  builder_.add_pos_y(pos_y);
  builder_.add_pos_x(pos_x);
  builder_.add_physics_id(physics_id);
  builder_.add_header(header);
  builder_.add_health(health);
  builder_.add_is_alive(is_alive);
  return builder_.Finish();
}

struct NetMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NetMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HEADER = 4,
    VT_PACKET_TYPE = 6,
    VT_PACKET = 8
  };
  const myu::net::PacketHeader *header() const {
    return GetPointer<const myu::net::PacketHeader *>(VT_HEADER);
  }
  myu::net::PacketUnion packet_type() const {
    return static_cast<myu::net::PacketUnion>(GetField<uint8_t>(VT_PACKET_TYPE, 0));
  }
  const void *packet() const {
    return GetPointer<const void *>(VT_PACKET);
  }
  template<typename T> const T *packet_as() const;
  const myu::net::FirePacket *packet_as_FirePacket() const {
    return packet_type() == myu::net::PacketUnion_FirePacket ? static_cast<const myu::net::FirePacket *>(packet()) : nullptr;
  }
  const myu::net::MovePacket *packet_as_MovePacket() const {
    return packet_type() == myu::net::PacketUnion_MovePacket ? static_cast<const myu::net::MovePacket *>(packet()) : nullptr;
  }
  const myu::net::PlayerStatePacket *packet_as_PlayerStatePacket() const {
    return packet_type() == myu::net::PacketUnion_PlayerStatePacket ? static_cast<const myu::net::PlayerStatePacket *>(packet()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyField<uint8_t>(verifier, VT_PACKET_TYPE, 1) &&
           VerifyOffset(verifier, VT_PACKET) &&
           VerifyPacketUnion(verifier, packet(), packet_type()) &&
           verifier.EndTable();
  }
};

template<> inline const myu::net::FirePacket *NetMessage::packet_as<myu::net::FirePacket>() const {
  return packet_as_FirePacket();
}

template<> inline const myu::net::MovePacket *NetMessage::packet_as<myu::net::MovePacket>() const {
  return packet_as_MovePacket();
}

template<> inline const myu::net::PlayerStatePacket *NetMessage::packet_as<myu::net::PlayerStatePacket>() const {
  return packet_as_PlayerStatePacket();
}

struct NetMessageBuilder {
  typedef NetMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_header(::flatbuffers::Offset<myu::net::PacketHeader> header) {
    fbb_.AddOffset(NetMessage::VT_HEADER, header);
  }
  void add_packet_type(myu::net::PacketUnion packet_type) {
    fbb_.AddElement<uint8_t>(NetMessage::VT_PACKET_TYPE, static_cast<uint8_t>(packet_type), 0);
  }
  void add_packet(::flatbuffers::Offset<void> packet) {
    fbb_.AddOffset(NetMessage::VT_PACKET, packet);
  }
  explicit NetMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NetMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NetMessage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NetMessage> CreateNetMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<myu::net::PacketHeader> header = 0,
    myu::net::PacketUnion packet_type = myu::net::PacketUnion_NONE,
    ::flatbuffers::Offset<void> packet = 0) {
  NetMessageBuilder builder_(_fbb);
  builder_.add_packet(packet);
  builder_.add_header(header);
  builder_.add_packet_type(packet_type);
  return builder_.Finish();
}

inline bool VerifyPacketUnion(::flatbuffers::Verifier &verifier, const void *obj, PacketUnion type) {
  switch (type) {
    case PacketUnion_NONE: {
      return true;
    }
    case PacketUnion_FirePacket: {
      auto ptr = reinterpret_cast<const myu::net::FirePacket *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PacketUnion_MovePacket: {
      auto ptr = reinterpret_cast<const myu::net::MovePacket *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PacketUnion_PlayerStatePacket: {
      auto ptr = reinterpret_cast<const myu::net::PlayerStatePacket *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyPacketUnionVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyPacketUnion(
        verifier,  values->Get(i), types->GetEnum<PacketUnion>(i))) {
      return false;
    }
  }
  return true;
}

inline const myu::net::NetMessage *GetNetMessage(const void *buf) {
  return ::flatbuffers::GetRoot<myu::net::NetMessage>(buf);
}

inline const myu::net::NetMessage *GetSizePrefixedNetMessage(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<myu::net::NetMessage>(buf);
}

inline bool VerifyNetMessageBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<myu::net::NetMessage>(nullptr);
}

inline bool VerifySizePrefixedNetMessageBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<myu::net::NetMessage>(nullptr);
}

inline void FinishNetMessageBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<myu::net::NetMessage> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedNetMessageBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<myu::net::NetMessage> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace net
}  // namespace myu

#endif  // FLATBUFFERS_GENERATED_RECEIVEGAMINGPACKET_MYU_NET_H_
