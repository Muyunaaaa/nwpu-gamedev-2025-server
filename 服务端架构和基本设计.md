# 服务端架构

## 1. 服务端整体架构设计

我们将架构分为五个核心层级：

### 1.1 网络通信层 (Network Layer)

- **技术选型**：**ENet (UDP)**。
- **职责**：收发原始数据包，处理客户端连接/断开。
- **实现**：`myu::NetWork` 单例类封装了 ENet 的操作，运行在独立的网络线程中。

### 1.2 协议解析层 (Protocol Layer)

- **技术选型**：**FlatBuffers**。
- **职责**：高效地序列化和反序列化网络消息。
- **实现**：定义在 `schemas/*.fbs`，生成代码在 `include/protocol/`。

------

## 2. 核心逻辑模块拆分

### 2.1 房间与流程控制器 (Match Controller)

负责驱动游戏流程的流转，采用状态机模式。

- **状态机 (State Pattern)**：
  - `WaitState`：等待玩家连接。
  - `WarmupState`：热身阶段。
  - `PrepareState`：回合准备阶段（购买时间）。
  - `GamingState`：战斗阶段。
  - `BombState`：C4 倒计时阶段。
  - `SettleState`：回合结算。
- **实现**：`MatchController` 单例管理当前状态。

### 2.2 游戏上下文 (Game Context)

管理游戏内的实体数据和全局状态。

- **职责**：
  - 管理所有玩家状态 (`PlayerState`)。
  - 处理击杀、死亡、助攻逻辑。
  - 经济系统结算（发钱、扣钱）。
  - 胜负判定逻辑。
- **实现**：`GameContext` 单例。

### 2.3 物理与战斗引擎 (Physics & Combat)

- **物理引擎**：集成 **JoltPhysics** 处理碰撞检测和物理模拟。
- **战斗逻辑**：
  - **命中检测**：服务端进行射线检测或碰撞体检测。
  - **伤害计算**：根据武器配置 (`weapons.json`) 和击中部位计算伤害。
  - **日志记录**：使用 `spdlog` 记录详细的移动 (`move_records.log`) 和射击 (`fire_records.log`) 日志用于调试和反作弊分析。

### 2.4 配置管理 (Configuration)

- **服务器配置**：`settings.toml` (使用 `toml++` 解析)。
- **武器配置**：`config/weapons.json` (使用 `nlohmann/json` 解析)。

------

## 3. 线程设计

### 3.1 核心线程模型：双线程架构

#### 3.1.1 主逻辑线程 (Main Logic Thread)

这是游戏的心脏，采用 **固定步长（Fixed Tick）** 循环（默认 60 TPS）。

- **负责内容**：
  - **网络包处理**：从接收队列取出指令并分发。
  - **状态机更新**：`MatchController::Tick()`。
  - **物理模拟**：`PhysicsEngine::Update()`。
  - **状态同步**：定期向客户端广播世界状态。
- **循环逻辑**：
  ```cpp
  while (running) {
      processNetworkPackets(); // 处理网络包
      updateGameLogic();       // 状态机与物理
      syncState();             // 状态同步
      waitForNextTick();       // 保持固定频率
  }
  ```

#### 3.1.2 网络 I/O 线程 (Network Thread)

- **负责内容**：运行 ENet 的 `host_service` 循环。
- **数据流向**：
  - **入站**：接收 UDP 包 -> 放入 `recv_packet_queue` -> 主线程读取。
  - **出站**：主线程放入 `send_packet_queue` -> 网络线程取出 -> 发送 UDP 包。
- **通信机制**：使用 `moodycamel::ConcurrentQueue` 实现无锁高效的线程间通信。

------

## 4. 关键交互逻辑设计

### 4.1 C4 爆破逻辑

- **下包**：
  - 玩家在包点区域长按 E。
  - 服务端校验位置和持有状态。
  - 成功后切换到 `BombState`。
- **拆包**：
  - CT 在 C4 附近长按 E。
  - 服务端校验是否有拆弹器（影响拆除时间）。

### 4.2 经济系统

- **初始资金**：$800。
- **奖励机制**：
  - 击杀奖励。
  - 胜负奖励。
  - 下包/拆包奖励。
- **购买限制**：仅在 `PrepareState` 且位于购买区域内允许购买。

------

## 5. 网络设计细节

### 5.1 NetWorkService

单例模式，封装 ENet。

```cpp
class NetWork {
    // ...
    moodycamel::ConcurrentQueue<RecvPacket> recv_packet_queue;
    moodycamel::ConcurrentQueue<SendPacket> send_packet_queue;
    // ...
    void startNetworkThread();
    // ...
};
```

### 5.2 数据包处理流程

1.  **网络线程**：`enet_host_service` 收到包 -> 封装为 `RecvPacket` -> `recv_packet_queue.enqueue()`.
2.  **主线程**：`recv_packet_queue.try_dequeue()` -> `Server::onClientPacket()` -> `HandlePacket` 分发处理。
3.  **回包**：主线程生成 `SendPacket` -> `send_packet_queue.enqueue()`.
4.  **网络线程**：`send_packet_queue.try_dequeue()` -> `enet_peer_send()`.
